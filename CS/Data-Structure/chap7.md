# 7. 查找

## 查找的基本概念

1. 查找

2. 查找表（查找结构）

3. 静态查找表；动态查找表

4. 关键字

5. 平均查找长度 $\mathrm{ASL}=\sum_{i=1}^nP_iC_i$

   n 为查找表长度；$P_i$是查找第i个元素的概率；$C_i$是找到第i个元素所需进行的比较次数

## 顺序查找和折半查找

### 顺序查找

> 线性查找，适用于顺序表和链表

#### 一般线性表的顺序查找

<details>
  <summary>code</summary>

```c++

```

</details>

查找成功时，平均查找长度为 $\mathrm{ASL}_\text{成功}=\displaystyle\sum_{i=1}^nP_i(n-i+1)$

每个元素查找概率相等时 $\mathrm{ASL}_\text{成功}{ = \displaystyle\sum _ { i = 1 }^nP_i(n-i+1)=\frac{n+1}2}$

查找不成功时，$\mathrm{ASL}_\text{不成功} = n + 1$

缺点：n较大时，平均查找长度较大，效率低

优点：对数据存储没有要求

线性的链表只能进行顺序查找

#### 有序表的顺序查找

> 关键字是有序的，查找是按顺序的

查找成功的平均查找长度和一般线性表的顺序查找一样。

查找不成功在相等查找概率的情形下为 

$\text{ASL}_\text{不成功}{ = \displaystyle\sum _ { j = 1 }^nq_j(l_j-1)=\frac{1+2+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}}$

$q_j$是到达第j个失败结点的概率；$l_j$是第j个失败结点的所在的层数。

### 折半查找

> 又称二分查找，仅适用于有序的顺序表

<details>
  <summary>code</summary>

```c++

```

</details>

折半查找的判定树，二叉平衡树

![描述折半查找过程的判定树](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831152357570.png)

查找成功的平均查找长度为

$\mathrm{ASL}=\cfrac{1}{n}\displaystyle\sum_{i=1}^nl_i=\frac{1}{n}(1\times1+2\times2+\cdots+h\times2^{h-1})=\frac{n+1}{n}\log_2(n+1)-1\approx\log_2(n+1)-1$

h 是树的高度，元素个数为 n 是树高 $h=\lceil\log_2(n+1)\rceil$。所以，折半查找的时间复杂度为 $O(log_2n)$

折半查找需要方便地定位查找区域，要求线性表必须具有==随机存取==的特性。仅适合于顺序存储结构，不适合链式存储结构，且要求关键字有序排列。

### 分块查找

> 又称索引顺序查找。
>
> 将查找表分为若干子块，块内元素无序，块间元素有序。再建立一个索引表，含有各块的最大关键词和各块中第一个元素的地址，按关键字有序排列。

块间顺序查找或折半查找，块内顺序查找

设索引查找和块内查找的平均查找长度分别为$L_I,L_S$，则分块查找的平均查找长度为 $ASL = L_I + L_S$

长度为 n 的查找表均匀地分为 6 块，每块有 s 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为

$\mathrm{ASL}=L_{\mathrm{I}}+L_{\mathrm{S}}=\cfrac{b+1}{2}+\cfrac{s+1}{2}=\cfrac{s^{2}+2s+n}{2s}$

若 $s = \sqrt{n}$，则平均查找长度取最小值 $\sqrt{n} + 1$

## 树型查找

### 二叉排序树（BST）

不是为了排序，而是提高查找、插入和删除的速度

#### 二叉排序树的定义

或为空树，或具有以下特性：

1. 若左子树非空，左子树所有元素小于根结点值
2. 若右子树非空，右子树所有元素大于根结点值
3. 左、右子树也分别是一棵二叉排序树

> 左小右大，中序遍历可以得到一个递增的有序序列

#### 二叉排序树的查找

> 从根结点开始，沿某个分支逐层向下比较。递归过程

非递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

#### 二叉排序树的插入

> 动态树表，树的结构不是一次生成的

插入结点过程：

原二叉排序树为空，直接插入；否则，若关键词小于根结点，则插入到左子树；若关键词大于根结点，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子

<details>
  <summary>code</summary>

```c++

```

</details>

#### 二叉排序树的构造

<details>
  <summary>code</summary>

```c++

```

</details>

#### 二叉排序树的删除

1. 被删除的是叶结点，直接删除
2. 若结点只有一棵左子树或右子树，让其子树代替其位置
3. 若有左、右两棵子树，则令其直接后继（或直接前驱）（==也就是中序第一个子女==）代替，然后从二叉排序树中删除这个代替它的结点，转换成第一或第二种情况

#### 二叉排序树的查找效率分析

左右子树高度之差不超过1（平衡二叉树），平均查找长度为 $O(log_2n)$

最坏情况下，只有左（右）孩子的单支树，退化为链表，平均查找长度为 O(n)

### 平衡二叉树(AVL)

#### 平衡二叉树的定义

> 插入和删除结点时，保证任意结点的左右子树高度之差的绝对值不超过1

Balanced Binary Tree/AVL

**平衡因子**：结点左子树与右子树的高度之差

AVL的平衡因子只可能为0、1或-1

#### 平衡二叉树的插入

##### LL

在A的左孩子的左子树插入导致不平衡

调整：A的左孩子结点右上旋

![LL](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831163358935.png)

##### RR

在A的右孩子的右子树插入导致不平衡

调整：A的右孩子结点左上旋

![RR](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831163449261.png)

##### LR

在A的左孩子的右子树插入导致不平衡

调整：A的左孩子的右孩子先左上旋再右上旋

![LR](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831163934185.png)

##### RL

在A的右孩子的左子树插入导致不平衡

调整：A的右孩子的左孩子先右上旋再左上旋

![RL](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831165124806.png)

#### 平衡二叉树的删除



#### 平衡二叉树的查找

平均查找长度 $O(log_2n)$

### 红黑树

#### 红黑树的定义

满足红黑性质的二叉排序树

1. 每个结点或是红色，或是黑色
2. 根结点是黑色的
3. 叶结点（虚构的外部结点，NULL结点）都是黑色的
4. 不存在两个相邻的红结点
5. 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点个数相同

**黑高**：从某结点出发（不含该结点），到达一个叶结点的任意一个简单路径上的黑结点总数。记为bh

根结点的黑高称为红黑树的黑高。

**结论1**：从根结点到叶结点的最长路径不大于最短路径的2倍

**结论2**：有n个内部结点的红黑树的高度 $h \le 2log_2(n+1)$ 

插入和删除比较少，查找比较多，适合AVL，否则适合红黑树。

#### 红黑树的插入

**结论3**：新插入红黑树中的结点初始着色为红色

1. 未破坏“非红红”，不需要调整
2. 黑叔：旋转+染色
   1. LL：右单旋，父换爷+染色 （父爷）
   2. RR：左单旋，父换爷+染色
   3. LR：左、右双旋，儿换爷+染色
   4. RL：右、左 双旋，儿换爷+染色
3. 红叔：染色+变新 叔父爷染色，爷变为新结点

![红黑树](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831203905611.png)

#### 红黑树的删除

删除时间复杂度 $O(log_2n)$

## B树和B+树

### B树及其基本操作

> m阶B树是所有结点的平衡因子均等于0的m路平衡查找树

m阶B树或为空树，或满足以下特性的m叉树：

1. 树中每个结点至多有m棵子树，即至多含有m-1个关键字

2. 若根结点不是叶结点，则至少有两棵子树

3. 除根结点外的所有非叶结点至少有$\left\lceil m/2\right\rceil$棵子树

4. 所有非叶结点的结构如下

   | n    | P~0~ | K~1~ | P~1~ | K~2~ | P~2~ | ...  | K~n~ | P~n~ |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

   $K_i(i=1,2,\cdotp\cdotp\cdotp,n)$为结点关键字，且满足 $K_1<K_2<\cdots<K_n;P_i(i=0,1,\cdots,n)$为指向子树根结点的指针，指针 P~i-1~ 所指子树中所有结点的关键字均小于 K~i~ ， P~i~ 所指子树中所有结点的关键字均大于 K~i~ ，$n(\lceil m/2\rceil-1\leq n\leq m-1)$为关键字个数

5. 所有叶结点都出现在同一层，且不带信息

![5阶B树实例](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831205830575.png)

#### B树的高度（磁盘存取次数）

> B树大部分操作所需磁盘存取次数与B树高度成正比

若 n ≥ 1，则对任何一棵包含 n 个关键字、高度为 h、阶数为 m 的B树：

1. 关键字个数满足 $n\leq(m-1)(1+m+m^2+\cdotp\cdotp\cdotp+m^{h-1})=m^h-1,$ 因此 $h\geq\log_m(n+1)$

2. 若让每个结点中的关键字个数最少，则容纳同样多关键字的B树的高度达到最大。

   第一层至少1个结点，第二层至少2个结点，第 h + 1 层至少 $2(\lceil m/2\rceil)^{h-1}$ 个结点。

   $n+1\geq2(\lceil m/2\rceil)^{h-1},\quad h\leq\log_{\lceil m/2\rceil}((n+1)/2)+1$

#### B树的查找

#### B树的插入

![结点“分裂”示意](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831213158305.png)

#### B树的删除

![删除非终端结点](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831213228875.png)

![删除终端结点](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831213310875.png)

### B+树的基本概念

1. 每个分支最多有m棵子树
2. 非根结点至少有两棵子树，其他分支结点至少有$\left\lceil m/2\right\rceil$棵子树
3. 结点的子树个数与关键字个数相等
4. 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来
5. 所有分支结点中间仅包含它的各个子结点中关键字的最大值及指向其子结点的指针

B树与B+树差异

1. B+树，n个关键字的结点只含有n棵子树；B树含有n+1棵子树
2. B+树，每个结点的关键字个数n的范围是 $[m/2]\leq n\leq m$（根结点 $1 \leq n\leq m$）；B树 $[m/2] - 1\leq n\leq m - 1$（根结点 $1 \leq n\leq m - 1$）
3. B+树中叶结点包含了所有关键字；B树关键字不重复
4. B+树，所以非叶结点只起索引作用，仅包含对应子树的最大关键字和指向该子树的指针，不含关键字的存储地址

![B+树结构示意](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230831213109505.png)

:heavy_exclamation_mark: 题型

1. 给定结点数求最大/小高度
2. 给定高度求最多最少结点数
3. B 树的插入与删除

## 散列表

### 散列表的基本概念

散列函数：把查找表中的关键字映射成该关键字对应的地址的函数

冲突：两个不同关键字映射到同一地址

散列表：根据关键字直接进行访问的数据结构

理想情况下，查找时间复杂度为O(1)

### 散列函数的构造方法

1. 定义域包含所有关键字，值域依赖于散列表的大小或地址范围
2. 尽可能等概率、均匀地分布
3. 尽量简单，能在较短时间内计算

#### 直接定址法

> 直接取某个线性函数值

$H(\mathrm{key})=\mathrm{key~}\text{或 }H(\mathrm{key})=a{\times}\mathrm{key}+b$

最简单，且不会产生冲突。适合关键字分布基本连续的情况，若不连续，则空位较多，造成空间浪费。

#### 除留余数法

假定散列表表长为m，取一个不大于m 但最接近或等于m的质数 p

$H(\mathrm{key})=\mathrm{key~}\%p$

关键为选好p

#### 数字分析法

设关键字是 r 进制数(如十进制数)，而 r 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等;而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数

#### 平方取中法

取关键字的平方值的中间几位作为散列地址

适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数

### 处理冲突的方法

#### 开放定址法

$H_i=(H(\text{key})+d_i)\%m$

$H(\mathrm{key})\text{为散列函数;}i=0,1,2,\cdots,k\text{(}k\leq m-1);m\text{ 表示散列表表长;}d_i\text{为增量序列。}$

1. 线性探测法。$d_i=0,1,2,\cdotp\cdotp\cdotp,m-1$
2. 平方探测法。$d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$
3. 双散列法。$d_i=\mathrm{Hash}_2(\mathrm{key})$
4. 伪随机序列法。

#### 拉链法（链接法，chaining）

冲突存储在链表中

### 散列查找及性能分析

:star2:效率取决于三个因素：散列函数、处理冲突的方法和装填因子

装填因子：一个表的装满程度



## 不熟悉知识点

- [ ] B 树求结点，高度
- [ ] B 树插入删除
- [ ] 散列表查找成功与失败的查找长度计算

