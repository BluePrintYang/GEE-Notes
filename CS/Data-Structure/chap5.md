# 5. 树与二叉树

## 树的基本概念

### 树的定义

> n个结点的有限集。n=0时，称为空树

非空树满足

1. 有且仅有一个特定的称为**根**的结点
2. n > 1 时，其余结点可分为m个互不相交的有限集$T_1, T_2, \cdots, T_m$，其中每个集合本身又是一棵树，并且称为根的**子树**

树是一种递归的数据结构。是一种逻辑结构，也是一种分层结构。

特点：

1. 树的根结点没有前驱，除根结点外的所有结点有且仅有一个前驱
2. 树中所有结点都可以有零个或多个后继

适合表示具有层次结构的数据。n个结点的树中有n-1条边。

### 基本术语

1. **祖先**：对于叶子结点来说，从其到根结点的路径上的任意结点都为其祖先；**子孙**：K为其祖先的子孙；最接近K的祖先为其**双亲**；K为其双亲的**孩子**；根结点是唯一没有双亲的结点；有相同双亲的结点称为**兄弟**
2. **结点的度**：一个结点的孩子的个数；**树的度**：树中结点的最大度
3. **分支结点**：度大于0的结点；**叶子结点**：度为0的结点
4. 结点的深度、高度和层次
   1. **结点的层次**：从根结点开始定义，根结点为第一层，根的子结点为第二层，以此类推。双亲在同一层的结点互为**堂兄弟**
   2. **结点的深度**：从根结点开始自顶向下逐层累加的
   3. **结点的高度**：从叶结点开始自底向上逐层累加的
   4. **树的高度**：树中结点的最大层数
5. **有序树和无序树**：树中结点的各子树从左到右是有次序的，不能交换，称该树为有序树，否则为无序树
6. **路径和路径长度**：路径：两个结点之间所经过的结点序列；路径长度：路径上所经过的边的个数（路径是从上到下的）
7. **森林**：m棵互不相交的==树的集合==

### :star2:树的性质

1. 结点数等于所有结点的度数之和加1
2. 度为m的树中第i层上至多有$m^{i-1}$个结点
3. 高度为h的m叉树至多有$(m^h - 1)/(m - 1)$个结点（推导公式$S = 1 + m + m^2 + \cdots + m ^{h - 1} + m^h = (m^h - 1)/(m - 1)$）
4. 具有n个结点的m叉树的最小高度为$\lceil log_m (n(m-1) + 1) \rceil$

## 二叉树的概念

### 二叉树的定义及其主要特征

#### 二叉树的定义

每个结点至多有两棵子树，子树有左右之分，不能颠倒

二叉树是$n（n \ge 0）$个结点的有限集合

1. 或为空二叉树（n=0）
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。（左子树和右子树分别是一棵二叉树）

二叉树与度为2的有序树的区别

1. 度为2的有序树至少有3个结点；二叉树可以为空
2. 度为2的有序树的孩子的左有次序是相对另一孩子而言的，若只有一个孩子则无需区分左右；二叉树无论孩子树是否为2，都需要区分左右孩子

#### 几个特殊的二叉树

1. **满二叉树**：高度为h，且含有$2^h - 1$个结点。即每层都含有最多个结点。

   若按层序编号，根结点为1，自上而下，从左到右。对于编号为i的结点，若有双亲，其双亲为$\lfloor i / 2 \rfloor$，若有左孩子，则左孩子为`2i`；若有右孩子，则右孩子为`2i+1`

2. **完全二叉树**：高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应

   1. 若$i \le \lfloor n / 2 \rfloor$，则结点i为分支结点，否则为叶结点
   2. 叶结点只可能在层次最大的两层出现。层次最大中的叶结点，都依次排列在该层最左边的位置上。
   3. :star2:若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子
   4. 按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点
   5. :star2:若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点  ==（编号为n/2）== 只有左孩子，没有右孩子，其余分支结点左、右孩子都有

3. **二叉排序树**：左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左右子树又各是一棵二叉排序树

4. **平衡二叉树**：树上==任意一个结点==的左右子树的深度之差不超过1

#### :star2:二叉树的性质

1. :star2:非空二叉树上的叶结点数等于度为2的结点数加1，即$n_0 = n_2 + 1$
2. 非空二叉树第k层至多有$2^{k-1}$个结点（k ≥ 1）
3. 高度为h的二叉树至多有$2^{h} - 1$个结点（h ≥ 1）
4. 完全二叉树按从上到下，从左到右顺序编号后
   1. 当 i > 1 时，结点 i 的双亲编号为$\lfloor i / 2 \rfloor$，即当 i 为偶数时，其双亲的编号为 i/2，它是双亲的左孩子；当i为奇数时，其双亲的编号为(i-1)/2，它是双亲的右孩子。==（奇数右孩子，偶数左孩子，双亲除以2向下取整）==
   2. 当 2i ≤ n 时，结点 i 的左孩子编号为 2i，否则无左孩子。==（左孩子为编号乘2）==
   3. 当 2i + 1 ≤ n 时，结点 i 的右孩子编号为 2i + 1，否则无右孩子。==（左孩子为编号乘2加1）==
   4. 结点 i 所在的层次（深度）为$\lfloor log_2 i \rfloor + 1$
5. 具有 n 个结点的完全二叉树的高度为$\lceil log_2 (n+1) \rceil 或 \lfloor log_2 n \rfloor + 1$

### 二叉树的存储结构

#### 顺序存储结构

> 一组地址连续的存储单元依次自上而下，从左到右存储完全二叉树上的结点元素

满二叉树和完全二叉树比较合适。树上编号为 i 的结点元素存储在数组下标为 i - 1 的分量上。

而一般二叉树则需要添加一些并不存在的空结点。

#### 链式存储结构

采用链表结点来存储二叉树中的每个结点。

- 数据域：data
- 左指针域：lchild
- 右指针域：rchild

<details>
  <summary>code</summary>

```c++

```

</details>

在含有 n 个结点的二叉链表 中，含有 n + 1 个空链域

## 二叉树的遍历和线索二叉树

### 二叉树的遍历

> 按某条搜索路径访问树中的每个结点，使每个结点都被访问一次，且仅被访问一次

常见遍历次序有先序（NLR）、中序（LNR）和后序（LRN），其中“序”是指根结点在何时被访问。

#### 先序遍历（PreOrder）

若二叉树为空，则什么也不做，否则

1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

#### 中序遍历（InOrder）

若二叉树为空，则什么也不做，否则

1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

#### 后序遍历（PostOrder）

若二叉树为空，则什么也不做，否则

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

时间复杂度`O(n)`

递归遍历中，递归工作栈的栈深恰好为树的深度，所以，最坏情况下，空间复杂度为`O(n)`

#### 递归算法和非递归算法的转换

##### 中序遍历

1. 沿着根的左孩子，依次入栈，直到左孩子为空
2. 栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不为空，将右子树转执行1

<details>
  <summary>InOrder</summary>

```c++

```

</details>

##### 先序遍历

与中序类似，只需将访问结点的操作放在入栈前面

<details>
  <summary>PreOrder</summary>

```c++

```

</details>

##### 后序遍历

要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点

思路分析：从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为如果其有右孩子，还需按相同的规则对右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈并访问，要么右子树为空，要么右子树刚被访问完。

:star2:访问一个结点p时，栈中结点恰好是p结点的所有祖先，从栈底到栈顶结点再加上p结点，刚好构成从根结点到p结点的一条路径。

<details>
  <summary>PostOrder</summary>

```c++

```

</details>

#### 层次遍历

借助一个队列。首先将根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。完成入队后出队，访问出队结点，如此反复，直至队列为空。

<details>
  <summary>code</summary>

```c++

```

</details>

#### 由遍历序列构造二叉树

:star2:由二叉树的先序序列和中序序列可以唯一确定一棵二叉树

先序遍历中，第一个结点一定是根结点；中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点左子树的中序序列，后一个子序列是根结点右子树的中序序列。

:star2:后序序列和中序序列也可以唯一确定一棵二叉树

后序遍历最后一个结点为根结点

:star2:由二叉树的层序序列和中序序列也可以唯一确定一棵二叉树

先序+后序无法唯一确定

### 线索二叉树

#### 线索二叉树的基本概念

利用空指针存储前驱或后继结点，加快查找结点的前驱和后继结点

若无左子树，令`lchild`指向其前驱结点；若无右子树，令`rchild`指向其后继结点。还需增加两个标志域标识指针域。

| lchild | ltag | data | rtag | rchild |
| ------ | ---- | ---- | ---- | ------ |

$$
   ltag = \begin{cases}
      0, & lchild 域指示结点的左孩子\\
      1, & lchild 域指示结点的前驱
   \end{cases}\\
   rtag = \begin{cases}
      0, & rchild 域指示结点的右孩子\\
      1, & rchild 域指示结点的后驱
   \end{cases}
$$

<details>
  <summary>code</summary>

```c++

```

</details>

线索链表

#### 中序线索二叉树的构造

二叉树的**线索化**是将二叉链表中的空指针改为指向前驱或后继的线索。

前驱和后继只有在遍历的时候才能得到，因此线索化实质就是遍历一次二叉树。

设指针`pre`指向刚刚访问过的结点，指针`p`指向正在访问的结点，即`pre`指向`p`的前驱。在中序遍历的过程中，检查`p`的左指针是否为空，若为空就将它指向`pre`；检查`pre`的右指针是否为空，若为空就将它指向`p`

<details>
  <summary>code</summary>

```c++

```

</details>

为了方便，可以在二叉树的线索链表上也添加一个头结点，令其`lchild`域指向二叉树根结点，其`rchild`域指向中序遍历的最后一个结点；令二叉树中序序列中的第一个结点的`lchild`域和最后一个结点的`rchild`均指向头结点。

好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历

![带头结点的中序线索二叉树](https://p.ipic.vip/3sc9we.png)

#### 中序线索二叉树的遍历

> 中序线索二叉树的结点隐含了线索二叉树的前驱和后继信息。

在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。

若右标志为1，则右链为后继，否则遍历右子树中第一个访问的结点（右子树最左下的结点）为其后继。

1. 求中序线索二叉树中中序序列下的第一个结点

<details>
  <summary>code</summary>

```c++

```

</details>

2. 求中序线索二叉树中结点p在中序序列下的后继

<details>
  <summary>code</summary>

```c++

```

</details>

3. 中序线索二叉树的中序遍历

<details>
  <summary>code</summary>

```c++

```

</details>

#### 先序线索二叉树和后序线索二叉树

> 只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置

在先序线索二叉树中找结点的后继：有左孩子，则左孩子就是后继；无左孩子但有右孩子，则右孩子就是后继；如果叶结点，则右链域直接指示了结点的后继

后序线索二叉树找结点的后继：

1. 结点x是二叉树的根，则后继为空
2. 结点x是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继为双亲
3. 结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点

## 树、森林

### 树的存储结构

> 要求能唯一地反映树中各结点之间的逻辑关系

#### 双亲表示法

> 一组连续空间来存储每个结点，同时每个结点中增设一个伪指针，指示其双亲结点在数组中的位置

<details>
  <summary>code</summary>

```c++

```

</details>

唯一双亲性质，可以很快地得到每个结点的双亲，但是求结点的孩子时需要遍历整个结构

![树的双亲表示法](https://p.ipic.vip/nndo7x.png)

#### 孩子表示法

> 每个结点的孩子结点都用单链表链接起来形成一个线性结构，n个结点就有n个孩子链表

寻找孩子非常直接，但寻找双亲需要遍历n个结点中孩子链表指针域所指向的n个孩子链表

#### 孩子兄弟表示法

> 又称二叉树表示法，以==二叉链表==作为树的存储结构

每个结点包含三部分：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）==（左孩子右兄弟）==

<details>
  <summary>code</summary>

```c++

```

</details>

方便地实现树转换为二叉树的操作，易于查找结点的孩子

缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个`parent`域指向其父结点，则查找结点的父结点也很方便

![孩子表示法和兄弟表示法](https://p.ipic.vip/6egq92.png)

### 树、森林与二叉树的转化

> 二叉链表可以作为媒介导出树与二叉树的对应关系

即给定一棵树，可以找到唯一的一棵二叉树与之对应

树转换为二叉树：==“左孩子右兄弟”==。每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟。由于根结点没有兄弟，所以==对应的二叉树没有右子树==。

树转二叉树的画法：

1. 兄弟结点之间连一条线
2. 对每个结点，只保留它与第一个孩子的连线，其他孩子的连线全部断开
3. 以树根为轴心，顺时针旋转45度

森林转二叉树：

1. 将森林中每棵树转换为对应的二叉树
2. 每棵树的根视为兄弟关系，在每棵树的根之间加一根连线
3. 以第一棵树的根为轴心顺时针旋转45度

二叉树转森林：二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将其根的右链断开。二叉树根的右子树又可视为一个二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树转换为树，就得到了森林。

![森林与二叉树对应关系](https://p.ipic.vip/ensq3e.png)

### 树和森林的遍历

#### 树的遍历

> 某种方式访问树中的每个结点，且仅访问一次

1. **先根遍历**。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵守先根后子树的规则。与对应二叉树先序序列相同
2. **后根遍历**。若树非空，先依次遍历根结点的每棵子树，在访问根结点，遍历子树时仍遵守先子树后根的规则。与对应二叉树中序序列相同

#### 森林的遍历

1. 先序遍历森林
   - 访问森林中第一棵树的根结点
   - 先序遍历第一棵树中根结点的子树森林
   - 先序遍历除第一棵树之后剩余的树构成的森林
2. 中序遍历森林
   - 中序遍历森林中第一棵树的根结点的子树森林
   - 访问第一棵树的根结点
   - 中序遍历除第一棵树之后剩余的树构成的森林

当森林转换为二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为对应二叉树的先序和中序遍历。

## 树和二叉树的应用

### 哈夫曼树和哈夫曼编码

#### 哈夫曼树的定义

- **权**：树中结点被赋予一个表示某种意义的数值
- **结点的带权路径长度**：从根结点到任意结点的路径长度（经过的边数）与该结点权值的乘积
- **树的带权路径长度**：所有叶结点的带权路径长度之和，记为$WPL = \displaystyle \sum _ {i=1} ^{n} w_i l_i \enspace w_i \text{是第i个叶结点所带的权值，} l_i \text{是该叶结点到根结点的路径长度}$ 

在含有n个带权叶结点的二叉树中，带权路径长度最小的二叉树称为**哈夫曼树**，也称**最优二叉树**

#### 哈夫曼树的构造

给定n个权值分别为$w_1, w_2, \cdots, w_n$的结点

1. 将这n个结点分别作为n棵仅含一个结点二叉树，构成森林F
2. 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和
3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中
4. 重复2和3，直至F中只剩下一棵树为止

哈夫曼树特点

1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越长
2. 构造过程中共新建了 n - 1 个结点（双分支结点），因此哈夫曼树的结点总数为 2n - 1
3. 每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点

#### 哈夫曼编码

**固定长度编码**：对每个字符采用相等长度二进制位表示

**可变长度编码**：允许对不同字符用不等长的二进制表示

对频率高的字符采用短编码，对频率低的字符赋以较长一些的编码，从而使字符平均长度减短，起到压缩数据的效果 。

**前缀编码**：没有一个编码是另一个编码的前缀。

由哈夫曼树得到哈夫曼编码：

1. 将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。
2. 所有字符结点都出现在叶结点。字符编码解释为从根至该字符的路径上边标记的序列，边标记为“0”表示“转向左孩子”，标记为“1”表示”转向右孩子“

哈夫曼树的WPL可视为最终编码得到的二进制编码的长度

哈夫曼树不唯一，但WPL必然相同且最优

### 并查集

> 简单的集合表示

三种操作

1. Initial(S)
2. Union(S, Root1, Root2)
3. Find(S, x)

通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。

为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结点。

并查集结构题定义

<details>
  <summary>code</summary>

```c++

```

</details>

初始化操作

<details>
  <summary>code</summary>

```c++

```

</details>

Find操作

<details>
  <summary>code</summary>

```c++

```

</details>

判断两个元素是否属于同一个集合，只需分别找到它们的根结点，比较根结点是否相同即可

Union操作

<details>
  <summary>code</summary>

```c++

```

</details>