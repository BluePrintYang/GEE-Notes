# 5. 树与二叉树

## 树的基本概念

### 树的定义

> n个结点的有限集。n=0时，称为空树

非空树满足

1. 有且仅有一个特定的称为**根**的结点
2. n > 1 时，其余结点可分为m个互不相交的有限集$T_1, T_2, \cdots, T_m$，其中每个集合本身又是一棵树，并且称为根的**子树**

树是一种递归的数据结构。是一种逻辑结构，也是一种分层结构。

特点：

1. 树的根结点没有前驱，除根结点外的所有结点有且仅有一个前驱
2. 树中所有结点都可以有零个或多个后继

适合表示具有层次结构的数据。n个结点的树中有n-1条边。

### 基本术语

1. **祖先**：对于叶子结点来说，从其到根结点的路径上的任意结点都为其祖先；**子孙**：K为其祖先的子孙；最接近K的祖先为其**双亲**；K为其双亲的**孩子**；根结点是唯一没有双亲的结点；有相同双亲的结点称为**兄弟**
2. **结点的度**：一个结点的孩子的个数；**树的度**：树中结点的最大度
3. **分支结点**：度大于0的结点；**叶子结点**：度为0的结点
4. 结点的深度、高度和层次
   1. **结点的层次**：从根结点开始定义，根结点为第一层，根的子结点为第二层，以此类推。双亲在同一层的结点互为**堂兄弟**
   2. **结点的深度**：从根结点开始自顶向下逐层累加的
   3. **结点的高度**：从叶结点开始自底向上逐层累加的
   4. **树的高度**：树中结点的最大层数
5. **有序树和无序树**：树中结点的各子树从左到右是有次序的，不能交换，称该树为有序树，否则为无序树
6. **路径和路径长度**：路径：两个结点之间所经过的结点序列；路径长度：路径上所经过的边的个数（路径是从上到下的）
7. **森林**：m棵互不相交的==树的集合==

### :star2:树的性质

1. 结点数等于所有结点的度数之和加1
2. 度为m的树中第i层上至多有$m^{i-1}$个结点
3. 高度为h的m叉树至多有$(m^h - 1)/(m - 1)$个结点（推导公式$S = 1 + m + m^2 + \cdots + m ^{h - 1} + m^h = (m^h - 1)/(m - 1)$）
4. 具有n个结点的m叉树的最小高度为$\lceil log_m (n(m-1) + 1) \rceil$

## 二叉树的概念

### 二叉树的定义及其主要特征

#### 二叉树的定义

每个结点至多有两棵子树，子树有左右之分，不能颠倒

二叉树是$n（n \ge 0）$个结点的有限集合

1. 或为空二叉树（n=0）
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。（左子树和右子树分别是一棵二叉树）

二叉树与度为2的有序树的区别

1. 度为2的有序树至少有3个结点；二叉树可以为空
2. 度为2的有序树的孩子的左有次序是相对另一孩子而言的，若只有一个孩子则无需区分左右；二叉树无论孩子树是否为2，都需要区分左右孩子

#### 几个特殊的二叉树

1. **满二叉树**：高度为h，且含有$2^h - 1$个结点。即每层都含有最多个结点。

   若按层序编号，根结点为1，自上而下，从左到右。对于编号为i的结点，若有双亲，其双亲为$\lfloor i / 2 \rfloor$，若有左孩子，则左孩子为`2i`；若有右孩子，则右孩子为`2i+1`

2. **完全二叉树**：高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应

   1. 若$i \le \lfloor n / 2 \rfloor$，则结点i为分支结点，否则为叶结点
   2. 叶结点只可能在层次最大的两层出现。层次最大中的叶结点，都依次排列在该层最左边的位置上。
   3. :star2:若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子
   4. 按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点
   5. :star2:若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点==（编号为n/2）==只有左孩子，没有右孩子，其余分支结点左、右孩子都有

3. **二叉排序树**：左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左右子树又各是一棵二叉排序树

4. **平衡二叉树**：树上==任意一个结点==的左右子树的深度之差不超过1

#### :star2:二叉树的性质

1. :star2:非空二叉树上的叶结点数等于度为2的结点数加1，即$n_0 = n_2 + 1$
2. 非空二叉树第k层至多有$2^{k-1}$个结点（k ≥ 1）
3. 高度为h的二叉树至多有$2^{h} - 1$个结点（h ≥ 1）
4. 完全二叉树按从上到下，从左到右顺序编号后
   1. 当 i > 1 时，结点 i 的双亲编号为$\lfloor i / 2 \rfloor$，即当 i 为偶数时，其双亲的编号为 i/2，它是双亲的左孩子；当i为奇数时，其双亲的编号为(i-1)/2，它是双亲的右孩子。==（奇数右孩子，偶数左孩子，双亲除以2向下取整）==
   2. 当 2i ≤ n 时，结点 i 的左孩子编号为 2i，否则无左孩子。==（左孩子为编号乘2）==
   3. 当 2i + 1 ≤ n 时，结点 i 的右孩子编号为 2i + 1，否则无右孩子。==（左孩子为编号乘2加1）==
   4. 结点 i 所在的层次（深度）为$\lfloor log_2 i \rfloor + 1$
5. 具有 n 个结点的完全二叉树的高度为$\lceil log_2 (n+1) \rceil 或 \lfloor log_2 n \rfloor + 1$

### 二叉树的存储结构

#### 顺序存储结构

> 一组地址连续的存储单元依次自上而下，从左到右存储完全二叉树上的结点元素

满二叉树和完全二叉树比较合适。树上编号为 i 的结点元素存储在数组下标为 i - 1 的分量上。

而一般二叉树则需要添加一些并不存在的空结点。

#### 链式存储结构

采用链表结点来存储二叉树中的每个结点。

- 数据域：data
- 左指针域：lchild
- 右指针域：rchild

<details>
  <summary>code</summary>

```c++

```

</details>

在含有 n 个结点的二叉链表 中，含有 n + 1 个空链域

## 二叉树的遍历和线索二叉树

### 二叉树的遍历

> 按某条搜索路径访问树中的每个结点，使每个结点都被访问一次，且仅被访问一次

常见遍历次序有先序（NLR）、中序（LNR）和后序（LRN），其中“序”是指根结点在何时被访问。

#### 先序遍历（PreOrder）

若二叉树为空，则什么也不做，否则

1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

#### 中序遍历（InOrder）

若二叉树为空，则什么也不做，否则

1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

#### 后序遍历（PostOrder）

若二叉树为空，则什么也不做，否则

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

递归算法

<details>
  <summary>code</summary>

```c++

```

</details>

时间复杂度`O(n)`

递归遍历中，递归工作栈的栈深恰好为树的深度，所以，最坏情况下，空间复杂度为`O(n)`

#### 递归算法和非递归算法的转换

##### 中序遍历

1. 沿着根的左孩子，依次入栈，直到左孩子为空
2. 栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不为空，将右子树转执行1

<details>
  <summary>InOrder</summary>

```c++

```

</details>

##### 先序遍历

与中序类似，只需将访问结点的操作放在入栈前面

<details>
  <summary>PreOrder</summary>

```c++

```

</details>

##### 后序遍历

要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点

思路分析：从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为如果其有右孩子，还需按相同的规则对右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈并访问，要么右子树为空，要么右子树刚被访问完。

:star2:访问一个结点p时，栈中结点恰好是p结点的所有祖先，从栈底到栈顶结点再加上p结点，刚好构成从根结点到p结点的一条路径。

<details>
  <summary>PostOrder</summary>

```c++

```

</details>

#### 层次遍历

借助一个队列。首先将根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。完成入队后出队，访问出队结点，如此反复，直至队列为空。

<details>
  <summary>code</summary>

```c++

```

</details>

#### 由遍历序列构造二叉树

:star2:由二叉树的先序序列和中序序列可以唯一确定一棵二叉树

先序遍历中，第一个结点一定是根结点；中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点左子树的中序序列，后一个子序列是根结点右子树的中序序列。

:star2:后序序列和中序序列也可以唯一确定一棵二叉树

后序遍历最后一个结点为根结点

:star2:由二叉树的层序序列和中序序列也可以唯一确定一棵二叉树

先序+后序无法唯一确定

### 线索二叉树

#### 线索二叉树的基本概念

#### 中序线索二叉树的构造

#### 中序线索二叉树的遍历

#### 先序线索二叉树和后序线索二叉树

## 树、森林

### 树的存储结构

#### 双亲表示法

#### 孩子表示法

#### 孩子兄弟表示法

### 树、森林与二叉树的转化

### 树和森林的遍历

## 树和二叉树的应用

### 哈夫曼树和哈夫曼编码

#### 哈夫曼树的定义

#### 哈夫曼树的构造

#### 哈夫曼编码

### 并查集