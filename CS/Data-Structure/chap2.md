# 2. 线性表

## 线性表的定义和基本操作

### 线性表的定义

==相同==数据类型的n个数据元素的<u>有序列表</u>

特点

- 元素个数有限
- 元素具有逻辑上的顺序性，有先后次序
- 都是数据元素，每个都是单个元素
- 数据类型都相同（占有相同大小空间）
- 元素具有抽象性（仅讨论元素间逻辑关系）

:bangbang: 线性表是逻辑结构，表示元素一对一的相邻关系。顺序表和链表是指存储结构。

### 线性表的基本操作

- InitList(&L)
- Length(L)
- LocateElem(L, e)
- GetElem(L, i)
- ListInsert(&L, i, e)
- ListDelete(&L, i, &e)
- PrintList(L)
- Empty(L)
- DestroyList(&L)

## 线性表的顺序表示

### 顺序表的定义

> 线性表的顺序存储

地址连续，逻辑上相邻的物理上也相邻。即逻辑顺序与物理顺序相同。

```c++
#define MaxSize 50
typedef struct
{
    ElemType data[MaxSize];
    int length;
} SqList;
```

```c++
#define InitSize 100
typedef struct
{
    ElemType *data;
    int MaxSize, length;
} SqList;
```

```c++
// C 初始动态分配
L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);

// C++ 初始动态分配
L.data = new ElemType[InitSize];
```

最主要特点：随机访问。（通过首地址以及元素序号可在O(1)时间内找到指定元素）

存储密度高，结点指存储数据。

逻辑上相邻的物理上也相邻。（插入删除需要大量移动操作）

### 顺序表上的基本操作

1. 插入操作

```c++
bool ListInsert(SqList &L, int i, ElemType e)
{
    if (i < 1 || i > L.length + 1)
    {
        return false;
    }
    if (L.length >= MaxSize)
    {
        return false;
    }
    for (int j = L.length; j >= i; j--)
    {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}
```

最好情况：在表尾插入，不执行后移语句，时间复杂度为O(1)
最坏情况：在表头插入，后移语句执行n次，时间复杂度为O(n)
平均情况：移动次数$\frac{n}{2}$，时间复杂度为O(n)
因此，顺序性插入算法平均时间复杂度为O(n)

2. 删除操作

```c++
bool ListDelete(SqList &L, int i, ElemType &e)
{
    if (i < 1 || i > L.length)
    {
        return false;
    }
    e = L.data[i - 1];
    for (int j = i; j < L.length; j++)
    {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return true;
}
```

最好情况：删除表尾元素，无需移动元素，时间复杂度为O(1)
最坏情况：删除表头元素，移动所有元素，时间复杂度为O(n)
平均情况：移动次数$\frac{n-1}{2}$，时间复杂度为O(n)
因此，顺序表删除算法平均时间复杂度为O(n)

3. 按值查找（顺序查找）

```c++
int LocateElem(SqList L, ElemType e)
{
    int i;
    for (i = 0; i < L.length; i++)
    {
        if (isEqual(L.data[i], e))
        {
            return i + 1;
        }
    }
    return 0;
}
```

最好情况：查找表头元素，比较一次，时间复杂度为O(1)
最坏情况：查找表尾元素（或不存在），比较所有元素，时间复杂度为O(n)
平均情况：比较次数$\frac{n+1}{2}$，时间复杂度为O(n)
因此，顺序表按值查找平均时间复杂度为O(n)

## 顺序表的链式表示

### 单链表的定义

### 单链表上基本操作的实现

#### 采用头插法建立单链表

新结点插入到当前链表的表头

#### 采用尾插法建立单链表

新结点插入到当前链表的表尾

#### 按序号查找结点

#### 按值查找表结点

#### 插入结点操作

#### 删除结点操作

#### 求表长操作

### 双链表

在单链表的基础上增加了一个前驱指针

#### 双链表的插入操作

#### 双链表的删除操作

### 循环链表

#### 循环单链表

> 与单链表的区别是最后一个结点的指针不是`NULL`，而是指向头结点

判空条件：头结点指针是否指向头结点

单链表只能从表头开始遍历，循环单链表可以从任意位置遍历

:star2:有时对循环单链表不设头指针而设尾指针。设头指针时，对表尾插入元素需要O(n)时间复杂度；而设尾指针时，`r->next`即为头指针，对表头表尾插入都只需要O(1)时间复杂度

#### 循环双链表

> 头结点的`prior`指针指向尾结点

判空条件：头结点`prior`域和`next`域都为L

### 静态链表

> 借助数组来描述线性表的链式存储结构。指针为数组下标
>

### 顺序表和链表的比较

#### 存取（读写）方式

顺序表可以顺序存取，也可以随机存取；链表只能从表头顺序存取。

#### 逻辑结构与物理结构

顺序存储时，逻辑上相邻的物理上也相邻；链式存储时，逻辑上相邻物理上不一定相邻。

#### 查找、插入和删除操作

按值查找，顺序表无序时，两者时间复杂度都为O(n)；顺序表有序时，采用折半查找，时间复杂度为O(logn)

按序号查找，顺序表O(1)；链表O(n)

插入、删除：顺序表O(n)；链表O(1)

#### 空间分配

顺序表静态存储时，需要预先分配空间；动态分配虽然可以扩充空间，但需要移动大量元素。

链式存储只在需要时申请分配。

##### 基于存储考虑

难以估计长度时，不宜采用顺序表；链表存储密度小于1

基于运算考虑

经常按序号访问，采用顺序表；经常插入删除，采用链表

基于环境考虑