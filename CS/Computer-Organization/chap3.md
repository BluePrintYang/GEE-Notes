# 3. 存储系统

## 存储器概述

### 分类

#### 按在计算机中作用（层次）

1. 主存储器
2. 辅助存储器
3. 高速缓冲存储器

#### 按储存介质

#### 按存取方式

1. 随机存储器（RAM）

2. 只读存储器（ROM）

   断电内容保留、随机读取，写入速度比读取速度慢得多

3. 串行访问存储器

#### 按消息可保存性

1. 易失性存储器
2. 非易失性存储器

### 性能指标

#### 存储容量

> 存储字数 x 字长 （如 1M x 8 位）

#### 单位成本

#### 存储速度

### 多级层次的存储系统

## 主存储器

> 主存储器由DRAM实现，Cache由SRAM实现。都属于易失性存储器。

### SRAM芯片和DRAM芯片

#### SRAM工作原理

> 双稳态触发器（六晶体管MOS）记忆信息。非破坏性读出

#### DRAM工作原理

> 电荷存储信息，需要刷新

刷新方式

1. 集中刷新

   > 依次对所有行进行刷新
   >
   > 读写操作不受刷新影响，死时间较长

2. 分散刷新

   > 每行的刷新分散到各个工作周期：前半部分读写，后半部分刷新
   >
   > 没有死区，增加了存取周期

3. 异步刷新

   > 刷新周期除以行数，得到刷新间隔t，每隔t产生一次刷新请求
   >
   > 缩短了“死时间”

#### DRAM读写周期

#### SRAM与DRAM比较

#### 存储器芯片内部结构

### 只读存储器

#### 特点

支持随机存取，掉电不丢失，只供读出

#### 类型

1. 掩模式只读（MROM）写入以后任何人无法更改
2. 一次可编程只读（PROM）
3. 可擦除可编程（EPROM）
4. Flash
5. 固态硬盘（SSD）

### 主存储器基本组成

地址线的位数决定了主存地址空间的最大可寻址范围

:star2:DRAM 芯片容量较大，地址位数较多，为了减少芯片的地址引脚数，==通常采用地址引脚复用技术==，行地址和列地址通过相同的引脚分先后两次输入。行选通+列选通+地址引脚/2

### 多模块存储器

#### 单体多字存储器

存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。

一次并行读出m个字，地址必须顺序排列并处于同一存储单元。

缺点：指令和数据在主存内必须是连续存放的。

#### 多体并行存储器

1. 高位交叉编址

![高位交叉编址](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906160734848.png)

总是先在一个模块内访问，等该模块访问完才转到下一个，CPU总是按顺序访问存储模块，各模块不能被并行访问，因而不能提高存储器的吞吐率。

2. 低位交叉编址

![低位交叉编址](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906161024882.png)

程序连续存放在相邻模块中。在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。

设模块字长等于数据总线宽度，模块存取一个字的存取周期为 T ，总线传送周期为 r ，为实现流水线方式存取，存储器交叉模块数应大于等于
$$
m = T / r
$$
m 称为交叉存取度。每经过 r 时间延迟后启动下一个模块，模块数必须大于等于 m ，以保证启动某模块后经过 m x r 时间后再次启动该模块时，其上次的存取操作已经完成。

连续存取 m 个字所需的时间为
$$
t_1 = T + (m - 1) r
$$
顺序方式连续读取 m 个字的时间为 $t_2 = mT$

## 主存储器与CPU的连接

### 连接原理

![存储器芯片基本原理](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906164433756.png)

![引脚](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906165406860.png)

### 容量扩展

#### 位扩展法

将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。

下图为8片 8K x 1 位的RAM芯片组成 8 x 8 位的存储器

![位扩展示意图](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906165701735.png)

#### 字扩展法

增加存储器中字的数量，而位数不变。

下图为4片 16K x 8 位的RAM芯片组成 64K x 8 位的存储器

![字扩展示意图](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906170039865.png)

#### 字位同时扩展法

既增加存储字的数量，又增加存储字长

下图为8片 16K x 4 位的RAM芯片组成 64K x 8 位的存储器

![字位同时扩展](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230906170217263.png)

### 存储芯片的地址分配和片选

#### 线选法

某地址线信息为“0”时，选中。片选地址线每次寻址只能有一位有效，不允许同时有多位有效。

优点：不需要地址译码器，线路简单

缺点：地址空间不连续，选片的地址线必须低电平，不能充分利用系统的存储器空间，造成地址资源浪费

#### 译码片选法

000 选中第一片，001 选中第二片……

### 存储器与CPU的连接

#### 合理选择存储芯片

ROM 通常存放系统程序、标准子程序和各类常数，RAM 则是为用户编程而设置的。

#### 地址线的连接

CPU 地址线往往比存储芯片的地址线多。

通常将 CPU 地址线的低位与存储芯片的地址线相连，以选择芯片的某一单元（字选）。 

CPU 地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选）。

#### 数据线的连接

CPU 的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连;在不等时必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等

#### 读/写命令线的连接

CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。

#### 片选线的连接

片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端 $\overline {CS}$ 是否能接收到来自 CPU 的片选有效信号

## 外部存储器

### 磁盘存储器

优点：

- 存储容量大，位价格低
- 记录介质可重复使用
- 记录信息可长期保存而不丢失，甚至脱机存档
- 非破坏性读出，读出时不需要再生

缺点：存取速度慢，机械结构复杂，对工作环境要求较高

#### 磁盘存储器

##### 磁盘设备组成

1. 磁盘存储器的组成
   - 硬盘驱动器：核心部件是磁头组件和盘片组件
   - 磁盘控制器：磁盘存储器和主机的接口
2. 存储区域：一块磁盘含有若干记录面，每个记录面划分为若干磁道，每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位
   - 磁头数（Heads）：记录面数，一个记录面对应☝️磁头
   - 柱面数（Cylinders）：表示每面盘片上有多少条磁道
   - 扇区数（Sectors）：表示每条磁道上有多少个扇区

##### 磁记录原理

磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作

##### 磁盘的性能指标

1. 记录密度

2. 磁盘的容量

3. 平均存取时间

4. 数据传输速率

   假设转速为 r 转/秒，每条磁道容量为 N 字节，则数据传输速率为 $D_r = rN$

##### 磁盘地址

驱动器号	柱面（磁道）号	盘面号	扇区号

##### 磁盘工作过程

主要操作是寻址、读盘、写盘

读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据

#### 磁盘阵列

RAID（独立冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。

- RAID0：无冗余和无校验的磁盘阵列
- RAID1：镜像磁盘阵列
- RAID2：采用纠错的海明码的磁盘阵列
- ……

RAID0 把连续多个数据块交替的存放在不同的物理磁盘的扇区中，没有容错能力；RAID1使两个磁盘同时进行读写，互为备份。两个磁盘当一个使用，意味着容量少一半。

### 固态硬盘

基于闪存技术的存储器。数据以页为单位读写。

闪存块会磨损。均衡磨损技术。

## 高速缓冲存储器

### 程序的局部性原理

时间局部性：最近的未来要使用的信息，很可能是现在正在使用的信息

空间局部性：最近的未来要使用的信息，很可能与现在正在使用的信息在存储空间上是邻近的

### Cache的基本工作原理

Cache 和主存都被划分为相等的块，Cache 块又称 Cache 行，每块由若干字节组成，块的长度称为块长（Cache 行长）

CPU 与Cache 之间的数据交换以字为单位，而 Cache 与主存之间的数据交换则以 Cache 块为单位

实现 Cache 时需要解决以下关键问题

1. 数据查找
2. 地址映射
3. 替换策略
4. 写入策略

### Cache和主存的映射方式

Cache 行中的信息是主存中的某个块的副本，**地址映射**是指把主存地址空间映射到 Cache 地址空间

- **标记位**：加一个标记，用来定位是主存中哪一块的副本
- **有效位**：是否有效

#### 直接映射

主存中的每一块只能装入 Cache 中的唯一位置。

Cache 中这一块已有内容，则产生块冲突，原来的块被无条件替换出去。

实现简单，不够灵活，即使 Cache 其他地方空着也不能占用，块冲突概率最高，空间占用率最低
$$
Cache~ 行号 = 主存块号~ mod~ Cache~ 总行数
$$
假设 Cache 共有$2^c$行，主存有$2^m$行

主存块号的低c位正好是它要装入的 Cache 行号。给每个 Cache 设置一个长为 t = m - c 的标记（因为c位的信息就是 Cache 行号），当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。

![Cache 与主存映射关系](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230907170106920.png)

直接映射的地址结构

| 标记 | Cache 行号 | 块内地址 |
| ---- | ---------- | -------- |

CPU 访存过程

首先根据访存地址中间的c位，找到对应的 Cache 行，将对应 Cache 行中的标记和主存地址的高 t 位进行比较，若相等且有效位为 1，则访问 Cache 命中，此时根据主存地址中低位的块内地址，在对应的 Cache 行中存取信息；若不相等或有效位为0，则不命中，此时 CPU 从主存中读出该地址所在的一块信息送到对应的 Cache 行中，将有效位置1，并将标记设置为地址中的高 t 位，同时将该地址中的内容送 CPU。

![CPU 访存过程](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230907173452573.png)

#### 全相联映射

主存中的每一块可以装入 Cache 中的任何位置，每行的标记用于指出该行取自主存的哪一块

优点：比较灵活，Cache 冲突概率低，空间利用率高，命中率也高

缺点：标记的比较速度较慢，实现成本较高，通常需采用昂贵的==按内容寻址的相联存储器==进行地址映射

![全相联映射](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230907174228313.png)

全相联映射地址结构

| 标记 | 块内地址 |
| ---- | -------- |

#### 组相联映射

将 Cache 分为Q个大小相等的组，每个主存块可以装入固定组的任意一行。即组间直接映射，组内全相联映射

Q = 1 时为全相联映射，Q = Cache 行数时为直接映射

假设每个组有 r 个 Cache 行，则称之为 r 路组相联

![二路组相联](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230907174602593.png)
$$
Cache~ 组号 = 主存块号~ mod~ Cache~ 组数
$$
路数越大，即每行 Cache 行的数量越大，发生块冲突的概率越低。但相联比较电路也越复杂。

组相联映射地址结构

| 标记 | 组号 | 块内地址 |
| ---- | ---- | -------- |

CPU 访存过程

首先根据访存地址中间的组号，找到对应的 Cache 组；将对应 Cache 组中每个行的标记和主存地址的高位标记进行比较；若相等且有效位为 1，则访问 Cache 命中，此时根据主存地址中的块内地址，在对应的 Cache 行中存取信息；若不相等或虽相等但有效位为0，则不命中，此时 CPU 从主存中读出该地址所在的一块信息送到对应的 Cache 组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送 CPU。

### Cache中主存块的替换算法

直接映射只能放到固定的 Cache 行，无需考虑替换算法

1. 随机算法
2. 先进先出算法
3. 近期最少使用算法
4. 最不经常使用算法：将一段时间内被访问次数最少的存储行换出

### Cache写策略

#### 写命中的情况

##### 1. 全写法

> CPU 对 Cache 写命中时，同时把数据写入 Cache 和主存

实现简单，能随时保持主存数据的正确性；但增加了访存次数，降低了 Cache 效率。

可以增加一个写缓冲，减少直接写入主存的时间损耗。CPU 同时写数据到 Cache 和写缓冲，缓冲再控制将内容写入主存。可以解决速度不匹配的问题；但若出现频繁写时，会使写缓冲饱和溢出。

##### 2. 回写法

> CPU 对 Cache 写命中时，只把数据写入 Cache ，只有此块被换出时才写回主存

减少了访存次数，但存在数据不一致的隐患

Cache 行设置一个修改位（脏位）

#### 写不命中的情况

##### 1. 写分配法

> 加载主存中的块到 Cache 中，然后更新这个 Cache 块

试图利用程序的空间局部性，缺点是每次不命中都需要从主存中读取一块

##### 2. 非写分配法

> 只写入主存，不进行调块

非写分配法通常与全写法合用，写分配法通常与回写法合用

## 虚拟存储器

### 虚拟存储器的基本概念

### 页式虚拟存储器

#### 页表

#### 快表（TLB）

#### 具有TLB和Cache的多级存储系统

### 段式虚拟存储器

### 段页式虚拟存储器

### 虚拟存储器与Cache的比较

#### 相同之处

#### 不同之处
