# 3. 内存管理

## 内存管理概念

### 内存管理的基本原理和要求

主要功能

- 内存空间的分配与回收
- 地址转换：提供地址变换功能，将逻辑地址转换成相应的物理地址
- 内存空间的扩充：虚拟存储技术或自动覆盖技术，逻辑上扩充
- 内存共享：允许多个进程访问内存同一部分
- 存储保护：保证各道作业在各自存储空间运行，互不干扰

#### 程序的链接与装入

用户源程序变为可在内存中执行的程序，通常需要以下步骤

- 编译
- 链接
- 装入

##### 程序链接方式

1. 静态链接：程序运行之前，将各目标模块及它们所需的库函数链接成一个完成的装配模块，以后不再拆开。需要解决两个问题：
   1. 修改相对地址
   2. 变换外部调用符号
2. 装入时动态链接：边装入边链接。便于修改和更新，便于实现对目标模块的共享
3. 运行时动态链接：执行过程中未被用到的模块，都不会被调入内存和被链接到装入模块上。能加快程序的装入过程，还可节省大量的内存空间

##### 装入方式

1. 绝对装入：只适用于单道程序环境。逻辑地址与实际物理地址完全相同。

2. 可重定位装入（静态重定位）：作业一旦装入内存，整个允许期间不能在内存中移动，也不能再申请内存空间。

   **重定位**：在装入时对目标程序中指令和数据地址的修改过程

3. 动态运行时装入（动态重定位）：程序在内存中发生移动。程序在装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才开始。装入内存后的所有地址均为相对地址。需要==重定位寄存器==的支持。

   优点：可以将程序分配到==不连续==的存储区；在程序运行之前只装入部分即可运行；在运行期间根据需要动态申请分配；便于程序段的共享

#### 逻辑地址与物理地址

**相对地址**（或逻辑地址）：编译后，每个目标模块都从0号单元开始编址

进程在运行时，看到和使用的都是逻辑地址

**物理地址空间**：内存中物理单元的集合

**地址重定位**：装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址

操作系统通过内存管理部件（MMU）将进程使用的逻辑地址转换成物理地址

逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用

#### 进程的内存映像

进程的内存映像要素：

1. 代码段
2. 数据段
3. 进程控制块
4. 堆
5. 栈

代码段和数据段在程序调入内存时就指定了大小，堆和栈可以在运行时动态地扩展和收缩

#### 内存保护

确保每个进程都有一个单独的内存空间。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。

可采取两种方法

1. 在 CPU 中设置一对==上、下限寄存器==，存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
2. 采用**重定位寄存器**（又称**基地址寄存器**）和**界地址寄存器**（又称**限长寄存器**）来实现保护。重定位寄存器含最小的物理地址值，界地址寄存器含==逻辑地址的最大值==。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再交送内存单元。

实现内存保护需要重定位寄存器和界地址寄存器。重定位寄存器是用来“加”的，逻辑地址加重定位寄存器中的值，就能得到物理地址；界地址寄存器是用来“比”的，通过比较界地址寄存器的值与逻辑地址的值来判断是否越界。

加载重定位寄存器和界地址寄存器必须使用特权指令，只有操作系统内核才可以加载这两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，不允许用户程序修改。

#### 内存共享

只有那些只读的区域才可以共享。

**可重入代码（纯代码）**：允许多个进程同时访问但不允许被任何进程修改的代码

#### 内存分配与回收

存储管理方式发展：单一连续分配 -> 固定分区分配 -> 动态分区分配

连续分配 -> 离散分配 -- 页式存储管理

引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求

### 覆盖与交换

> 多道程序下用来扩充内存的两种方法

#### 覆盖

基本思想：把用户空间分为一个固定区和若干覆盖区。

经常活跃的部分放在固定区，其余部分按调用关系分段。首先将即将要访问的段放入覆盖区，其余段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

特点：打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，此外，内存中能更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。覆盖技术对用户和程序员不透明。

#### 交换

基本思想：

- **换出**：把处于等待状态的程序从内存移到辅存，把内存空间腾出来
- **换入**：把准备好竞争 CPU 运行的程序从辅存移到内存

理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行

:heavy_exclamation_mark:注意几个问题：

- 交换需要备份存储，通常是磁盘。必须足够大。
- 需要使每个进程的执行时间比交换时间长
- 若换出进程，必须确保进程完全处于空闲状态
- 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来很快
- 交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停
- 普通的交换使用不多，交换策略的某些变体在许多系统中仍发挥作用

交换技术主要在==不同进程==之间进行，覆盖技术则用于==同一个进程==中。

对于主存无法存放用户程序的矛盾，现代操作系统通过虚拟内存技术来解决的，覆盖技术则已成为历史；交换仍有较强生命力。

### 连续分配管理方式

> 为一个用户程序分配一个连续的内存空间

#### 单一连续分配

分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；在用户区内存中，仅有一道用户程序，即整个内存的用户空间由该程序独占

优点：简单，无外部碎片，无需进行内存保护，因为内存中永远只有一道程序。

缺点：只能用于==单用户、单任务==的操作系统中，有内部碎片，存储器的利用率极低。

#### 固定分区分配

> 将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。

划分方式

- 分区大小相等：程序太小会造成浪费，程序太大又无法装入，缺乏灵活性
- 分区大小不等：划分为多个较小的分区、适量的中等分区和少量的大分区

分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态

![固定分区表](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230910150728185.png)

问题：

1. 程序可能太大而放不进任何一个分区，这是需要采用覆盖技术来使用内存空间
2. 程序小于固定分区大小时，也要占用一个完整的内存分区，分区内部存在空间浪费，**内部碎片**

最简单的多道程序存储管理方式，无外部碎片，但不能实现多进程共享一个主存区，存储空间利用率低

#### 动态分区分配

> 根据进程的需要，动态地为之分配内存，并使分区的大小正好适合进程的需要。又称**可变分区分配**

随着时间的推移，内存中会产生越来越多小的内存块，内存利用率也随之下降。这些内存块称为**外部碎片**。可通过**紧凑**技术解决，即操作系统不时地对进程进行移动和整理。但需要动态重定位寄存器的支持，且相对费时。

![动态分区](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230910150805271.png)

##### 动态分区分配策略

1. 首次适应（First Fit）：找到大小能满足要求的第一个分区

   *通常是最好和最快的。但内存低地址部分出现很多小的空闲分区*

2. 临近适应（Next Fit）：又称**循环首次适应**算法，首次适应基础上，分配内存时从上次结束的位置开始

   *导致内存空间尾部分裂成小碎片*

3. 最佳适应（Best Fit）：分区按容量递增次序，找到第一个能满足要求且最小的空闲分区

   *性能通常很差，每次会留下很小的难以利用的内存块，产生最多的外部碎片*

4. 最坏适应（Worst Fit）：分区按容量递减次序，找到第一个能满足要求的，即最大的分区

   *会导致很快没有可用的大内存块*

![三种内存分配管理比较](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230910155059038.png)

>  以上三种内存分区管理方式有一个共同特点，用户程序在主存中都是连续存放的。
>
> 即使内存有 1GB 的空闲空间，若没有连续的 1GB 空间，1GB 的作业仍无法运行；若采用非连续分配，则作业所要求的 1GB 内存空间可以分散地分配在内存的各个区域，也需要额外的空间去存储它们（分散区域）的索引，这使得==分连续分配方式的存储密度低于连续分配方式==
>
> 固定分区会产生内部碎片，动态分区会产生外部碎片，利用率都比较低

### 基本分页存储管理

> 把主存空间划分为大小相等且固定的块，块相对比较小，作为主存的基本单位。每个进程也以块为单位进行划分，以块为单位逐个申请主存中的块空间。

形式上像分区相等的固定分区技术，**分页管理不会产生外部碎片**。进程只会在为最后一个不完整的块申请一个主存块空间时，才产生内部碎片。**每个进程平均只产生半个块大小的内部碎片**（也称页内碎片）

#### 分页存储的几个基本概念

##### 页面和页面大小

- **页**（或**页面**）：进程中的块
- **页框**（或**页帧**）：内存中的块
- **块**（或**盘块**）：外存

进程执行时申请主存空间，为每个页分配主存中的可用页框，==页框与页一一对应==。

页面大小应是2的整数幂

##### 地址结构

> 包括两部分：前一部分为页号 P，后一部分为页内偏移量 W。
>
> 地址长度为 32 位，0～11位为页内地址，即每页 4KB；12～31为页号，即最多允许 2^20^ 页

地址结构决定了虚拟内存的寻址空间有多大

##### 页表

> 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般放在内存中
>
> ==实现从页号到物理块号到地址映射==

页表由页表项组成，:heavy_exclamation_mark:注意区分 **页表项** 与 **地址结构**

第一部分都是页号，第二部分，页表项是物理内存中的块号，而地址是页内偏移量；页表项的第二部分与地址的第二部分共同组成物理地址

![页表的作用](https://raw.githubusercontent.com/BluePrintYang/PicHub/master/premaster/image-20230910155154605.png)

#### 基本地址变换机构

#### 具有快表的地址变换机构

#### 两级页表

### 基本分段存储管理

#### 分段

#### 段表

#### 地址变换机构

#### 段的共享与保护

### 段页式管理

## 虚拟内存管理

### 虚拟内存的基本概念

#### 传统存储管理方式的特征

#### 局部性原理

#### 虚拟存储器的定义和特征

#### 虚拟内存技术的实现

### 请求分页管理方式

#### 页表机制

#### 缺页中断机构

#### 地址变换机构

### 页框分配

#### 驻留集大小

#### 内存分配策略

#### 物理块调入算法

#### 调入页面的时机

#### 从何处调入页面

#### 如何调入页面

### 页面置换算法

#### 最佳（OPT）置换算法

#### 先进先出（FIFO）页面置换算法

#### 最近最久未使用（LRU）置换算法

#### 时钟（CLOCK）置换算法

### 抖动和工作集

#### 抖动

#### 工作集

### 内存映射文件

### 虚拟存储器性能影响因素

### 地址翻译
