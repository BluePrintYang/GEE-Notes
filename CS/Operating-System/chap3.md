# 3. 内存管理

## 内存管理概念

### 内存管理的基本原理和要求

主要功能

- 内存空间的分配与回收
- 地址转换：提供地址变换功能，将逻辑地址转换成相应的物理地址
- 内存空间的扩充
- 内存共享
- 存储保护

#### 程序的链接与装入

用户源程序变为可在内存中执行的程序，通常需要以下步骤

- 编译
- 链接
- 装入

##### 程序链接方式

1. 静态链接：程序运行之前，将各目标模块及它们所需的库函数链接成一个完成的装配模块，以后不再拆开。需要解决两个问题：
   1. 修改相对地址
   2. 变换外部调用符号
2. 装入时动态链接：边装入边链接。便于修改和更新，便于实现对目标模块的共享
3. 运行时动态链接：执行过程中未被用到的模块，都不会被调入内存和被链接到装入模块上。能加快程序的装入过程，还可节省大量的内存空间

##### 装入方式

1. 绝对装入：只适用于单道程序环境。逻辑地址与实际物理地址完全相同。

2. 可重定位装入（静态重定位）：作业一旦装入内存，整个允许期间不能在内存中移动，也不能再申请内存空间。

   **重定位**：在装入时对目标程序中指令和数据地址的修改过程

3. 动态运行时装入（动态重定位）：程序在内存中发生移动。程序在装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才开始。装入内存后的所有地址均为相对地址。需要==重定位寄存器==的支持。

   优点：可以将程序分配到不连续的存储区；在程序运行之前只装入部分即可运行；在运行期间根据需要动态申请分配；便于程序段的共享

#### 逻辑地址与物理地址

**相对地址**（或逻辑地址）：编译后，每个目标模块都从0号单元开始编址

进程在运行时，看到和使用的都是逻辑地址

**物理地址空间**：内存中物理单元的集合

**地址重定位**：装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址

操作系统通过内存管理部件（MMU）将进程使用的逻辑地址转换成物理地址

逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用

#### 进程的内存映像

进程的内存映像要素：

1. 代码段
2. 数据段
3. 进程控制块
4. 堆
5. 栈

代码段和数据段在程序调入内存时就指定了大小，堆和栈可以在运行时动态地扩展和收缩

#### 内存保护

确保每个进程都有一个单独的内存空间。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。

可采取两种方法

1. 在 CPU 中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
2. 采用**重定位寄存器**（又称**基地址寄存器**）和**界地址寄存器**（又称**限长寄存器**）来实现保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再交送内存单元。

实现内存保护需要重定位寄存器和界地址寄存器。重定位寄存器是用来“加”的，逻辑地址加重定位寄存器中的值，就能得到物理地址；界地址寄存器是用来“比”的，通过比较界地址寄存器的值与逻辑地址的值来判断是否越界。

加载重定位寄存器和界地址寄存器必须使用特权指令，只有操作系统内核才可以加载这两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，不允许用户程序修改。

#### 内存共享

只有那些只读的区域才可以共享。

**可重入代码（纯代码）**：允许多个进程同时访问但不允许被任何进程修改的代码

#### 内存分配与回收

存储管理方式发展：单一连续分配 -> 固定分区分配 -> 动态分区分配

连续分配 -> 离散分配 -- 页式存储管理

引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求

### 覆盖与交换

> 多道程序下用来扩充内存的两种方法

#### 覆盖

基本思想：把用户空间分为一个固定区和若干覆盖区。

经常活跃的部分放在固定区，其余部分按调用关系分段。首先将即将要访问的段放入覆盖区，其余段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

特点：打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，此外，内存中能更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。覆盖技术对用户和程序员不透明。

#### 交换

基本思想：

- **换出**：把处于等待状态的程序从内存移到辅存，把内存空间腾出来
- **换入**：把准备好竞争 CPU 运行的程序从辅存移到内存

理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行

:heavy_exclamation_mark:注意几个问题：

- 交换需要备份存储，通常是磁盘。必须足够大。
- 需要使每个进程的执行时间比交换时间长
- 若换出进程，必须确保进程完全处于空闲状态
- 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来很快
- 交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停
- 普通的交换使用不多，交换策略的某些变体在许多系统中仍发挥作用

交换技术主要在==不同进程==之间进行，覆盖技术则用于==同一个进程==中。

对于主存无法存放用户程序的矛盾，现代操作系统通过虚拟内存技术来解决的，覆盖技术则已成为历史；交换仍有较强生命力。

### 连续分配管理方式

> 为一个用户程序分配一个连续的内存空间

#### 单一连续分配

分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；在用户区内存中，仅有一道用户程序，即整个内存的用户空间由该程序独占

优点：简单，无外部碎片，无需进行内存保护，因为内存中永远只有一道程序。

缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。

#### 固定分区分配

#### 动态分区分配

### 基本分页存储管理

#### 分页存储的几个基本概念

#### 基本地址变换机构

#### 具有快表的地址变换机构

#### 两级页表

### 基本分段存储管理

#### 分段

#### 段表

#### 地址变换机构

#### 段的共享与保护

### 段页式管理

## 虚拟内存管理

### 虚拟内存的基本概念

#### 传统存储管理方式的特征

#### 局部性原理

#### 虚拟存储器的定义和特征

#### 虚拟内存技术的实现

### 请求分页管理方式

#### 页表机制

#### 缺页中断机构

#### 地址变换机构

### 页框分配

#### 驻留集大小

#### 内存分配策略

#### 物理块调入算法

#### 调入页面的时机

#### 从何处调入页面

#### 如何调入页面

### 页面置换算法

#### 最佳（OPT）置换算法

#### 先进先出（FIFO）页面置换算法

#### 最近最久未使用（LRU）置换算法

#### 时钟（CLOCK）置换算法

### 抖动和工作集

#### 抖动

#### 工作集

### 内存映射文件

### 虚拟存储器性能影响因素

### 地址翻译
